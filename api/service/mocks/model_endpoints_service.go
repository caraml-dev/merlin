// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/gojek/merlin/models"
	mock "github.com/stretchr/testify/mock"
)

// ModelEndpointsService is an autogenerated mock type for the ModelEndpointsService type
type ModelEndpointsService struct {
	mock.Mock
}

type ModelEndpointsService_DeployEndpoint struct {
	*mock.Call
}

func (_m ModelEndpointsService_DeployEndpoint) Return(_a0 *models.ModelEndpoint, _a1 error) *ModelEndpointsService_DeployEndpoint {
	return &ModelEndpointsService_DeployEndpoint{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ModelEndpointsService) OnDeployEndpoint(ctx context.Context, model *models.Model, endpoint *models.ModelEndpoint) *ModelEndpointsService_DeployEndpoint {
	c := _m.On("DeployEndpoint", ctx, model, endpoint)
	return &ModelEndpointsService_DeployEndpoint{Call: c}
}

func (_m *ModelEndpointsService) OnDeployEndpointMatch(matchers ...interface{}) *ModelEndpointsService_DeployEndpoint {
	c := _m.On("DeployEndpoint", matchers...)
	return &ModelEndpointsService_DeployEndpoint{Call: c}
}

// DeployEndpoint provides a mock function with given fields: ctx, model, endpoint
func (_m *ModelEndpointsService) DeployEndpoint(ctx context.Context, model *models.Model, endpoint *models.ModelEndpoint) (*models.ModelEndpoint, error) {
	ret := _m.Called(ctx, model, endpoint)

	var r0 *models.ModelEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, *models.Model, *models.ModelEndpoint) *models.ModelEndpoint); ok {
		r0 = rf(ctx, model, endpoint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ModelEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Model, *models.ModelEndpoint) error); ok {
		r1 = rf(ctx, model, endpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ModelEndpointsService_FindByID struct {
	*mock.Call
}

func (_m ModelEndpointsService_FindByID) Return(_a0 *models.ModelEndpoint, _a1 error) *ModelEndpointsService_FindByID {
	return &ModelEndpointsService_FindByID{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ModelEndpointsService) OnFindByID(ctx context.Context, id models.ID) *ModelEndpointsService_FindByID {
	c := _m.On("FindByID", ctx, id)
	return &ModelEndpointsService_FindByID{Call: c}
}

func (_m *ModelEndpointsService) OnFindByIDMatch(matchers ...interface{}) *ModelEndpointsService_FindByID {
	c := _m.On("FindByID", matchers...)
	return &ModelEndpointsService_FindByID{Call: c}
}

// FindByID provides a mock function with given fields: ctx, id
func (_m *ModelEndpointsService) FindByID(ctx context.Context, id models.ID) (*models.ModelEndpoint, error) {
	ret := _m.Called(ctx, id)

	var r0 *models.ModelEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, models.ID) *models.ModelEndpoint); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ModelEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ModelEndpointsService_ListModelEndpoints struct {
	*mock.Call
}

func (_m ModelEndpointsService_ListModelEndpoints) Return(_a0 []*models.ModelEndpoint, _a1 error) *ModelEndpointsService_ListModelEndpoints {
	return &ModelEndpointsService_ListModelEndpoints{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ModelEndpointsService) OnListModelEndpoints(ctx context.Context, modelID models.ID) *ModelEndpointsService_ListModelEndpoints {
	c := _m.On("ListModelEndpoints", ctx, modelID)
	return &ModelEndpointsService_ListModelEndpoints{Call: c}
}

func (_m *ModelEndpointsService) OnListModelEndpointsMatch(matchers ...interface{}) *ModelEndpointsService_ListModelEndpoints {
	c := _m.On("ListModelEndpoints", matchers...)
	return &ModelEndpointsService_ListModelEndpoints{Call: c}
}

// ListModelEndpoints provides a mock function with given fields: ctx, modelID
func (_m *ModelEndpointsService) ListModelEndpoints(ctx context.Context, modelID models.ID) ([]*models.ModelEndpoint, error) {
	ret := _m.Called(ctx, modelID)

	var r0 []*models.ModelEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, models.ID) []*models.ModelEndpoint); ok {
		r0 = rf(ctx, modelID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ModelEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.ID) error); ok {
		r1 = rf(ctx, modelID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ModelEndpointsService_ListModelEndpointsInProject struct {
	*mock.Call
}

func (_m ModelEndpointsService_ListModelEndpointsInProject) Return(_a0 []*models.ModelEndpoint, _a1 error) *ModelEndpointsService_ListModelEndpointsInProject {
	return &ModelEndpointsService_ListModelEndpointsInProject{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ModelEndpointsService) OnListModelEndpointsInProject(ctx context.Context, projectID models.ID, region string) *ModelEndpointsService_ListModelEndpointsInProject {
	c := _m.On("ListModelEndpointsInProject", ctx, projectID, region)
	return &ModelEndpointsService_ListModelEndpointsInProject{Call: c}
}

func (_m *ModelEndpointsService) OnListModelEndpointsInProjectMatch(matchers ...interface{}) *ModelEndpointsService_ListModelEndpointsInProject {
	c := _m.On("ListModelEndpointsInProject", matchers...)
	return &ModelEndpointsService_ListModelEndpointsInProject{Call: c}
}

// ListModelEndpointsInProject provides a mock function with given fields: ctx, projectID, region
func (_m *ModelEndpointsService) ListModelEndpointsInProject(ctx context.Context, projectID models.ID, region string) ([]*models.ModelEndpoint, error) {
	ret := _m.Called(ctx, projectID, region)

	var r0 []*models.ModelEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, models.ID, string) []*models.ModelEndpoint); ok {
		r0 = rf(ctx, projectID, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ModelEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.ID, string) error); ok {
		r1 = rf(ctx, projectID, region)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ModelEndpointsService_Save struct {
	*mock.Call
}

func (_m ModelEndpointsService_Save) Return(_a0 *models.ModelEndpoint, _a1 error) *ModelEndpointsService_Save {
	return &ModelEndpointsService_Save{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ModelEndpointsService) OnSave(ctx context.Context, endpoint *models.ModelEndpoint) *ModelEndpointsService_Save {
	c := _m.On("Save", ctx, endpoint)
	return &ModelEndpointsService_Save{Call: c}
}

func (_m *ModelEndpointsService) OnSaveMatch(matchers ...interface{}) *ModelEndpointsService_Save {
	c := _m.On("Save", matchers...)
	return &ModelEndpointsService_Save{Call: c}
}

// Save provides a mock function with given fields: ctx, endpoint
func (_m *ModelEndpointsService) Save(ctx context.Context, endpoint *models.ModelEndpoint) (*models.ModelEndpoint, error) {
	ret := _m.Called(ctx, endpoint)

	var r0 *models.ModelEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, *models.ModelEndpoint) *models.ModelEndpoint); ok {
		r0 = rf(ctx, endpoint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ModelEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.ModelEndpoint) error); ok {
		r1 = rf(ctx, endpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ModelEndpointsService_UndeployEndpoint struct {
	*mock.Call
}

func (_m ModelEndpointsService_UndeployEndpoint) Return(_a0 *models.ModelEndpoint, _a1 error) *ModelEndpointsService_UndeployEndpoint {
	return &ModelEndpointsService_UndeployEndpoint{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ModelEndpointsService) OnUndeployEndpoint(ctx context.Context, model *models.Model, endpoint *models.ModelEndpoint) *ModelEndpointsService_UndeployEndpoint {
	c := _m.On("UndeployEndpoint", ctx, model, endpoint)
	return &ModelEndpointsService_UndeployEndpoint{Call: c}
}

func (_m *ModelEndpointsService) OnUndeployEndpointMatch(matchers ...interface{}) *ModelEndpointsService_UndeployEndpoint {
	c := _m.On("UndeployEndpoint", matchers...)
	return &ModelEndpointsService_UndeployEndpoint{Call: c}
}

// UndeployEndpoint provides a mock function with given fields: ctx, model, endpoint
func (_m *ModelEndpointsService) UndeployEndpoint(ctx context.Context, model *models.Model, endpoint *models.ModelEndpoint) (*models.ModelEndpoint, error) {
	ret := _m.Called(ctx, model, endpoint)

	var r0 *models.ModelEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, *models.Model, *models.ModelEndpoint) *models.ModelEndpoint); ok {
		r0 = rf(ctx, model, endpoint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ModelEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Model, *models.ModelEndpoint) error); ok {
		r1 = rf(ctx, model, endpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ModelEndpointsService_UpdateEndpoint struct {
	*mock.Call
}

func (_m ModelEndpointsService_UpdateEndpoint) Return(_a0 *models.ModelEndpoint, _a1 error) *ModelEndpointsService_UpdateEndpoint {
	return &ModelEndpointsService_UpdateEndpoint{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ModelEndpointsService) OnUpdateEndpoint(ctx context.Context, model *models.Model, endpoint *models.ModelEndpoint) *ModelEndpointsService_UpdateEndpoint {
	c := _m.On("UpdateEndpoint", ctx, model, endpoint)
	return &ModelEndpointsService_UpdateEndpoint{Call: c}
}

func (_m *ModelEndpointsService) OnUpdateEndpointMatch(matchers ...interface{}) *ModelEndpointsService_UpdateEndpoint {
	c := _m.On("UpdateEndpoint", matchers...)
	return &ModelEndpointsService_UpdateEndpoint{Call: c}
}

// UpdateEndpoint provides a mock function with given fields: ctx, model, endpoint
func (_m *ModelEndpointsService) UpdateEndpoint(ctx context.Context, model *models.Model, endpoint *models.ModelEndpoint) (*models.ModelEndpoint, error) {
	ret := _m.Called(ctx, model, endpoint)

	var r0 *models.ModelEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, *models.Model, *models.ModelEndpoint) *models.ModelEndpoint); ok {
		r0 = rf(ctx, model, endpoint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ModelEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Model, *models.ModelEndpoint) error); ok {
		r1 = rf(ctx, model, endpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
