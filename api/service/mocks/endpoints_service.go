// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/gojek/merlin/models"
	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// EndpointsService is an autogenerated mock type for the EndpointsService type
type EndpointsService struct {
	mock.Mock
}

type EndpointsService_CountEndpoints struct {
	*mock.Call
}

func (_m EndpointsService_CountEndpoints) Return(_a0 int, _a1 error) *EndpointsService_CountEndpoints {
	return &EndpointsService_CountEndpoints{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *EndpointsService) OnCountEndpoints(ctx context.Context, environment *models.Environment, model *models.Model) *EndpointsService_CountEndpoints {
	c := _m.On("CountEndpoints", ctx, environment, model)
	return &EndpointsService_CountEndpoints{Call: c}
}

func (_m *EndpointsService) OnCountEndpointsMatch(matchers ...interface{}) *EndpointsService_CountEndpoints {
	c := _m.On("CountEndpoints", matchers...)
	return &EndpointsService_CountEndpoints{Call: c}
}

// CountEndpoints provides a mock function with given fields: ctx, environment, model
func (_m *EndpointsService) CountEndpoints(ctx context.Context, environment *models.Environment, model *models.Model) (int, error) {
	ret := _m.Called(ctx, environment, model)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *models.Environment, *models.Model) int); ok {
		r0 = rf(ctx, environment, model)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Environment, *models.Model) error); ok {
		r1 = rf(ctx, environment, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type EndpointsService_DeployEndpoint struct {
	*mock.Call
}

func (_m EndpointsService_DeployEndpoint) Return(_a0 *models.VersionEndpoint, _a1 error) *EndpointsService_DeployEndpoint {
	return &EndpointsService_DeployEndpoint{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *EndpointsService) OnDeployEndpoint(ctx context.Context, environment *models.Environment, model *models.Model, version *models.Version, endpoint *models.VersionEndpoint) *EndpointsService_DeployEndpoint {
	c := _m.On("DeployEndpoint", ctx, environment, model, version, endpoint)
	return &EndpointsService_DeployEndpoint{Call: c}
}

func (_m *EndpointsService) OnDeployEndpointMatch(matchers ...interface{}) *EndpointsService_DeployEndpoint {
	c := _m.On("DeployEndpoint", matchers...)
	return &EndpointsService_DeployEndpoint{Call: c}
}

// DeployEndpoint provides a mock function with given fields: ctx, environment, model, version, endpoint
func (_m *EndpointsService) DeployEndpoint(ctx context.Context, environment *models.Environment, model *models.Model, version *models.Version, endpoint *models.VersionEndpoint) (*models.VersionEndpoint, error) {
	ret := _m.Called(ctx, environment, model, version, endpoint)

	var r0 *models.VersionEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, *models.Environment, *models.Model, *models.Version, *models.VersionEndpoint) *models.VersionEndpoint); ok {
		r0 = rf(ctx, environment, model, version, endpoint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.VersionEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Environment, *models.Model, *models.Version, *models.VersionEndpoint) error); ok {
		r1 = rf(ctx, environment, model, version, endpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type EndpointsService_FindByID struct {
	*mock.Call
}

func (_m EndpointsService_FindByID) Return(_a0 *models.VersionEndpoint, _a1 error) *EndpointsService_FindByID {
	return &EndpointsService_FindByID{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *EndpointsService) OnFindByID(ctx context.Context, uuid2 uuid.UUID) *EndpointsService_FindByID {
	c := _m.On("FindByID", ctx, uuid2)
	return &EndpointsService_FindByID{Call: c}
}

func (_m *EndpointsService) OnFindByIDMatch(matchers ...interface{}) *EndpointsService_FindByID {
	c := _m.On("FindByID", matchers...)
	return &EndpointsService_FindByID{Call: c}
}

// FindByID provides a mock function with given fields: ctx, uuid2
func (_m *EndpointsService) FindByID(ctx context.Context, uuid2 uuid.UUID) (*models.VersionEndpoint, error) {
	ret := _m.Called(ctx, uuid2)

	var r0 *models.VersionEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.VersionEndpoint); ok {
		r0 = rf(ctx, uuid2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.VersionEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, uuid2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type EndpointsService_ListContainers struct {
	*mock.Call
}

func (_m EndpointsService_ListContainers) Return(_a0 []*models.Container, _a1 error) *EndpointsService_ListContainers {
	return &EndpointsService_ListContainers{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *EndpointsService) OnListContainers(ctx context.Context, model *models.Model, version *models.Version, id uuid.UUID) *EndpointsService_ListContainers {
	c := _m.On("ListContainers", ctx, model, version, id)
	return &EndpointsService_ListContainers{Call: c}
}

func (_m *EndpointsService) OnListContainersMatch(matchers ...interface{}) *EndpointsService_ListContainers {
	c := _m.On("ListContainers", matchers...)
	return &EndpointsService_ListContainers{Call: c}
}

// ListContainers provides a mock function with given fields: ctx, model, version, id
func (_m *EndpointsService) ListContainers(ctx context.Context, model *models.Model, version *models.Version, id uuid.UUID) ([]*models.Container, error) {
	ret := _m.Called(ctx, model, version, id)

	var r0 []*models.Container
	if rf, ok := ret.Get(0).(func(context.Context, *models.Model, *models.Version, uuid.UUID) []*models.Container); ok {
		r0 = rf(ctx, model, version, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Container)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Model, *models.Version, uuid.UUID) error); ok {
		r1 = rf(ctx, model, version, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type EndpointsService_ListEndpoints struct {
	*mock.Call
}

func (_m EndpointsService_ListEndpoints) Return(_a0 []*models.VersionEndpoint, _a1 error) *EndpointsService_ListEndpoints {
	return &EndpointsService_ListEndpoints{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *EndpointsService) OnListEndpoints(ctx context.Context, model *models.Model, version *models.Version) *EndpointsService_ListEndpoints {
	c := _m.On("ListEndpoints", ctx, model, version)
	return &EndpointsService_ListEndpoints{Call: c}
}

func (_m *EndpointsService) OnListEndpointsMatch(matchers ...interface{}) *EndpointsService_ListEndpoints {
	c := _m.On("ListEndpoints", matchers...)
	return &EndpointsService_ListEndpoints{Call: c}
}

// ListEndpoints provides a mock function with given fields: ctx, model, version
func (_m *EndpointsService) ListEndpoints(ctx context.Context, model *models.Model, version *models.Version) ([]*models.VersionEndpoint, error) {
	ret := _m.Called(ctx, model, version)

	var r0 []*models.VersionEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, *models.Model, *models.Version) []*models.VersionEndpoint); ok {
		r0 = rf(ctx, model, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.VersionEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Model, *models.Version) error); ok {
		r1 = rf(ctx, model, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type EndpointsService_UndeployEndpoint struct {
	*mock.Call
}

func (_m EndpointsService_UndeployEndpoint) Return(_a0 *models.VersionEndpoint, _a1 error) *EndpointsService_UndeployEndpoint {
	return &EndpointsService_UndeployEndpoint{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *EndpointsService) OnUndeployEndpoint(ctx context.Context, environment *models.Environment, model *models.Model, version *models.Version, endpoint *models.VersionEndpoint) *EndpointsService_UndeployEndpoint {
	c := _m.On("UndeployEndpoint", ctx, environment, model, version, endpoint)
	return &EndpointsService_UndeployEndpoint{Call: c}
}

func (_m *EndpointsService) OnUndeployEndpointMatch(matchers ...interface{}) *EndpointsService_UndeployEndpoint {
	c := _m.On("UndeployEndpoint", matchers...)
	return &EndpointsService_UndeployEndpoint{Call: c}
}

// UndeployEndpoint provides a mock function with given fields: ctx, environment, model, version, endpoint
func (_m *EndpointsService) UndeployEndpoint(ctx context.Context, environment *models.Environment, model *models.Model, version *models.Version, endpoint *models.VersionEndpoint) (*models.VersionEndpoint, error) {
	ret := _m.Called(ctx, environment, model, version, endpoint)

	var r0 *models.VersionEndpoint
	if rf, ok := ret.Get(0).(func(context.Context, *models.Environment, *models.Model, *models.Version, *models.VersionEndpoint) *models.VersionEndpoint); ok {
		r0 = rf(ctx, environment, model, version, endpoint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.VersionEndpoint)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *models.Environment, *models.Model, *models.Version, *models.VersionEndpoint) error); ok {
		r1 = rf(ctx, environment, model, version, endpoint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
