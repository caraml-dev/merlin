// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/gojek/merlin/models"
	mock "github.com/stretchr/testify/mock"
)

// Controller is an autogenerated mock type for the Controller type
type Controller struct {
	mock.Mock
}

type Controller_GetContainers struct {
	*mock.Call
}

func (_m Controller_GetContainers) Return(_a0 []*models.Container, _a1 error) *Controller_GetContainers {
	return &Controller_GetContainers{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *Controller) OnGetContainers(ctx context.Context, namespace string, labelSelector string) *Controller_GetContainers {
	c := _m.On("GetContainers", ctx, namespace, labelSelector)
	return &Controller_GetContainers{Call: c}
}

func (_m *Controller) OnGetContainersMatch(matchers ...interface{}) *Controller_GetContainers {
	c := _m.On("GetContainers", matchers...)
	return &Controller_GetContainers{Call: c}
}

// GetContainers provides a mock function with given fields: ctx, namespace, labelSelector
func (_m *Controller) GetContainers(ctx context.Context, namespace string, labelSelector string) ([]*models.Container, error) {
	ret := _m.Called(ctx, namespace, labelSelector)

	var r0 []*models.Container
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*models.Container); ok {
		r0 = rf(ctx, namespace, labelSelector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Container)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, labelSelector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Run provides a mock function with given fields: stopCh
func (_m *Controller) Run(stopCh <-chan struct{}) {
	_m.Called(stopCh)
}

type Controller_Stop struct {
	*mock.Call
}

func (_m Controller_Stop) Return(_a0 error) *Controller_Stop {
	return &Controller_Stop{Call: _m.Call.Return(_a0)}
}

func (_m *Controller) OnStop(ctx context.Context, predictionJob *models.PredictionJob, namespace string) *Controller_Stop {
	c := _m.On("Stop", ctx, predictionJob, namespace)
	return &Controller_Stop{Call: c}
}

func (_m *Controller) OnStopMatch(matchers ...interface{}) *Controller_Stop {
	c := _m.On("Stop", matchers...)
	return &Controller_Stop{Call: c}
}

// Stop provides a mock function with given fields: ctx, predictionJob, namespace
func (_m *Controller) Stop(ctx context.Context, predictionJob *models.PredictionJob, namespace string) error {
	ret := _m.Called(ctx, predictionJob, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PredictionJob, string) error); ok {
		r0 = rf(ctx, predictionJob, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type Controller_Submit struct {
	*mock.Call
}

func (_m Controller_Submit) Return(_a0 error) *Controller_Submit {
	return &Controller_Submit{Call: _m.Call.Return(_a0)}
}

func (_m *Controller) OnSubmit(ctx context.Context, predictionJob *models.PredictionJob, namespace string) *Controller_Submit {
	c := _m.On("Submit", ctx, predictionJob, namespace)
	return &Controller_Submit{Call: c}
}

func (_m *Controller) OnSubmitMatch(matchers ...interface{}) *Controller_Submit {
	c := _m.On("Submit", matchers...)
	return &Controller_Submit{Call: c}
}

// Submit provides a mock function with given fields: ctx, predictionJob, namespace
func (_m *Controller) Submit(ctx context.Context, predictionJob *models.PredictionJob, namespace string) error {
	ret := _m.Called(ctx, predictionJob, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.PredictionJob, string) error); ok {
		r0 = rf(ctx, predictionJob, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
